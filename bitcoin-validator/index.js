const config = require('config')
const bcoin = require('bcoin').set(config.get('network'))
const request = require('request')
const diavgeiaURI = config.get('diavgeiaURI')
const chainsoAPI = 'https://chain.so/api/v2'

request.post(diavgeiaURI + '/api/getAllBlockchainCommits', function (err, httpResponse, diavgeiaData) {
  if (err) throw err
  var commits = (JSON.parse(diavgeiaData)).commits
  var txNum = commits.length
  var HDPublicKey = new bcoin.hd.fromBase58(config.get('xpubkey')) // eslint-disable-line
  var chain = HDPublicKey.derive(0)
  var validTransactions = Array.from(Array(txNum), () => 0)
  var diavgeiaAddresses = Array.from(Array(txNum + 1), () => '')
  var txIndexes = []
  // fill diavgeiaAddresses with the addresses generated by its HD wallet
  for (let i = 0; i < txNum; i++) {
    diavgeiaAddresses[i] = bcoin.keyring(chain.derive(i)).getAddress('base58')
    txIndexes.push(i)
  }
  diavgeiaAddresses[txNum] = bcoin.keyring(chain.derive(txNum)).getAddress('base58')

  const async = require('async')

  // requestDecisionsByTxIndex: Fetch decisions data from Diavgeia server
  let requestDecisionsByTxIndex = (txIndex) => {
    return new Promise((resolve, reject) => {
      request.post(diavgeiaURI + '/api/getDecisionsByTxIndex?txIndex=' + txIndex, function (err, httpResponse, txByIndexData) {
        if (err) return reject(err)
        const JSONB = require('json-buffer')
        resolve(JSONB.parse(txByIndexData))
      })
    })
  }
  async.mapLimit(txIndexes, 5, async function (txIndex) {
    let gzipedDecision = await requestDecisionsByTxIndex(txIndex)
    return gzipedDecision
  }, (err, gzipedDecisions) => {
    if (err) throw err
    // requestChainSo: Fetch diavgeia txs from chain.so server
    let requestChainSo = (txId, txIndex) => {
      return new Promise((resolve, reject) => {
        let network = config.get('network') === 'testnet' ? 'BTCTEST' : 'BTC'
        request.get(chainsoAPI + '/get_tx/' + network + '/' + txId, function (err, httpResponse, data) {
          if (err) return reject(err)
          resolve(JSON.parse(data))
        })
      })
    }
    /*
     * We have 3 alternative methods to check Diavgeia's blockchain txs:
     * 1. Download the full blockchain (fullnode) (Safe, but disk-space expensive, Slowest)
     * 2. Use SPV-node and add to Bloom Filter the addresses of Diavgeia
     *                     (Safe, and not so much disk-space expensive (about 370MB), Slow)
     * 3. Use a blockchain explorer (e.g. https://chain.so/) and make API request
     * to get information. This method is not as much safe as the two previous methods,
     * because someone might assume that Diavgeia has been in touch with the blockchain
     * explorer provider, in order to give citizens fake information.
     *
     **/

    async.mapLimit(commits, 1, async function (commit) {
      const response = await requestChainSo(commit.txId, commit.txIndex)
      return response
    }, (err, blockchainResults) => {
      // We have gathered all the data from the api
      if (err) throw err
      if (blockchainResults.length !== txNum) {
        throw new Error(`Diavgeia and blockchain are inconsistent
          Reason: There are ${blockchainResults.length} blockchain commits, while Diavgeia API shows citizens ${txNum} commits`)
      }
      // Then verify Diavgeia-Blockchain
      let verifyDiavgeia = (blockchainResults, txId, txIndex, decisionsPerTx) => {
        if (blockchainResults.status !== 'success') {
          throw new Error('Unexpected chainso API error')
        }
        let data = blockchainResults.data
        // tx must have exactly one input
        if (data.inputs.length !== 1) {
          throw new Error(`Diavgeia and blockchain are inconsistent!
            Reason: Transaction must have exactly one input (Diavgeia's address)`)
        }
        // Check for address mismatch
        if (data.inputs[0].address !== diavgeiaAddresses[txIndex]) {
          throw new Error(`Diavgeia and blockchain are inconsistent!
            Reason: Mismatched public addresses. Expecting ${diavgeiaAddresses[txIndex]} but ${data.inputs[0].address} found.`)
        }
        // tx must have exactly two outputs (PoB and Change Address)
        if (data.outputs.length !== 2) {
          throw new Error(`Diavgeia and blockchain are inconsistent!
            Reason: Transaction must have exactly two outputs (Proof of Burn output and Change Address)`)
        }
        let hexToAscii = (strInp) => {
          let hex = strInp.toString()
          let str = ''
          for (let n = 0; n < hex.length; n += 2) {
            str += String.fromCharCode(parseInt(hex.substr(n, 2), 16))
          }
          return str
        }
        data.outputs.forEach(output => {
          if (output.type === 'nulldata') {
            // PoB
            let scriptArray = output.script.split(' ')
            if (scriptArray[0] !== 'OP_RETURN') {
              throw new Error(`Diavgeia and blockchain are inconsistent!
                Reason: OP_RETURN is not the first part of the script code`)
            }
            let merkleRoot = scriptArray[1]
            let merkleRootChainSo = hexToAscii(merkleRoot)
            // Now calculate the merkle root from data of diavgeia
            var merkle = require('merkle-tree-gen')
            var crypto = require('crypto')
            let hashes = decisionsPerTx.map(decision => {
              let hash = crypto.createHash(config.get('hash_algorithm'))
              hash.update(Buffer.from(decision))
              return hash.digest('hex')
            })
            const merkleTreeArgs = {
              array: hashes,
              hashalgo: config.get('hash_algorithm'),
              hashlist: true
            }
            merkle.fromArray(merkleTreeArgs, function (err, tree) {
              if (err) throw err
              if (tree.root !== merkleRootChainSo) {
                throw new Error(`Diavgeia and blockchain are inconsistent!
                  Reason: Diavgeia API provides us the root: ${tree.root} while it has been commited to blockchain the following merkle root: ${merkleRootChainSo}`)
              }
            })
            // Now we have to check the hash of each decision.
          } else if (output.type === 'pubkeyhash') {
            // Change address
            if (output.address !== diavgeiaAddresses[txIndex + 1]) {
              throw new Error(`Diavgeia and blockchain are inconsistent!
                Reason: Diavgeia Change address is ${output.address} while it should be ${diavgeiaAddresses[txIndex + 1]}`)
            }
          }
        })
        validTransactions[txIndex] = 1
      }
      console.time('verificationTime')
      for (let i = 0; i < blockchainResults.length; i++) {
        let txIndex = commits[i].txIndex
        verifyDiavgeia(blockchainResults[i], commits[i].txId, txIndex, gzipedDecisions[txIndex])
      }
      // If everything is ok, validTransactions should be an array filled with 1
      let allTxChecked = validTransactions.every(tx => tx === 1)
      if (!allTxChecked) {
        throw new Error(`Diavgeia and blockchain are inconsistent!
          Reason: Not all txs have been checked`)
      }
      console.timeEnd('verificationTime')
    })
  })
})
